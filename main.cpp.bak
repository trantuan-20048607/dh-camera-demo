
#include "dh_camera.h"
#include <string>
#include "GxIAPI.h"
#include "DxImageProc.h"
#include <cstdio>
#include <cstdlib>
#include <pthread.h>
#include <unistd.h>
#include <iostream>
#include <ctime>

#define ACQ_BUFFER_NUM          5               ///< Acquisition Buffer Qty.
#define ACQ_TRANSFER_SIZE       (64 * 1024)     ///< Size of data transfer block
#define ACQ_TRANSFER_NUMBER_URB 64              ///< Qty. of data transfer block
#define FILE_NAME_LEN           50              ///< Save image file name length

#define PIXFMT_CVT_FAIL             -1             ///< PixelFormatConvert fail
#define PIXFMT_CVT_SUCCESS          0              ///< PixelFormatConvert success

// 校验
#define GX_VERIFY_EXIT(emStatus)  \
    if (emStatus != GX_STATUS_SUCCESS)     \
    {                                      \
        GetErrorString(emStatus);          \
        GXCloseDevice(g_hDevice);          \
        g_hDevice = nullptr;               \
        GXCloseLib();                      \
        return emStatus;                   \
    }

GX_DEV_HANDLE g_hDevice = nullptr;                     ///< Device handle
bool g_bColorFilter = false;                        ///< Color filter support flag
int64_t g_i64ColorFilter = GX_COLOR_FILTER_NONE;    ///< Color filter of device
bool g_bAcquisitionFlag = false;                    ///< Thread running flag
bool g_bSavePPMImage = false;                       ///< Save raw image flag
pthread_t g_nAcquisitionThreadID = 0;                ///< Thread ID of Acquisition thread

unsigned char *g_pRGBImageBuf = nullptr;               ///< Memory for RAW8toRGB24
unsigned char *g_pRaw8Image = nullptr;                 ///< Memory for RAW16toRAW8

int64_t g_nPayloadSize = 0;                         ///< Payload size

//Allocate the memory for pixel format transform
void PreForAcquisition();

//Release the memory allocated
void UnPreForAcquisition();

//Convert frame date to suitable pixel format
int PixelFormatConvert(PGX_FRAME_BUFFER);

//Save one frame to PPM image file
void SavePPMFile(uint32_t, uint32_t);

//Acquisition thread function
void *ProcGetImage(void *);

//Get description of error
void GetErrorString(GX_STATUS);

int main() {
    return 0;
}

void SavePPMFile(uint32_t ui32Width, uint32_t ui32Height) {
    char szName[FILE_NAME_LEN] = {0};

    static int nRawFileIndex = 0;

    if (g_pRGBImageBuf != nullptr) {
        FILE *phImageFile = nullptr;
        snprintf(szName, FILE_NAME_LEN, "Frame_%d.ppm", nRawFileIndex++);
        phImageFile = fopen(szName, "wb");
        if (phImageFile == nullptr) {
            printf("Create or Open %s failed!\n", szName);
            return;
        }
        //Save color image
        fprintf(phImageFile, "P6\n%u %u 255\n", ui32Width, ui32Height);
        fwrite(g_pRGBImageBuf, 1, g_nPayloadSize * 3, phImageFile);
        fclose(phImageFile);
        phImageFile = nullptr;
        printf("Save %s succeed!\n", szName);
    } else {
        printf("Save %s failed!\n", szName);
    }
}

int PixelFormatConvert(PGX_FRAME_BUFFER pFrameBuffer) {
    VxInt32 emDXStatus = DX_OK;

    // Convert RAW8 or RAW16 image to RGB24 image
    switch (pFrameBuffer->nPixelFormat) {
        case GX_PIXEL_FORMAT_BAYER_GR8:
        case GX_PIXEL_FORMAT_BAYER_RG8:
        case GX_PIXEL_FORMAT_BAYER_GB8:
        case GX_PIXEL_FORMAT_BAYER_BG8: {
            // Convert to the RGB image
            emDXStatus = DxRaw8toRGB24((unsigned char *) pFrameBuffer->pImgBuf, g_pRGBImageBuf, pFrameBuffer->nWidth,
                                       pFrameBuffer->nHeight,
                                       RAW2RGB_NEIGHBOUR, DX_PIXEL_COLOR_FILTER(g_i64ColorFilter), false);
            if (emDXStatus != DX_OK) {
                printf("DxRaw8toRGB24 Failed, Error Code: %d\n", emDXStatus);
                return PIXFMT_CVT_FAIL;
            }
            break;
        }
        case GX_PIXEL_FORMAT_BAYER_GR10:
        case GX_PIXEL_FORMAT_BAYER_RG10:
        case GX_PIXEL_FORMAT_BAYER_GB10:
        case GX_PIXEL_FORMAT_BAYER_BG10:
        case GX_PIXEL_FORMAT_BAYER_GR12:
        case GX_PIXEL_FORMAT_BAYER_RG12:
        case GX_PIXEL_FORMAT_BAYER_GB12:
        case GX_PIXEL_FORMAT_BAYER_BG12: {
            // Convert to the Raw8 image
            emDXStatus = DxRaw16toRaw8((unsigned char *) pFrameBuffer->pImgBuf, g_pRaw8Image, pFrameBuffer->nWidth,
                                       pFrameBuffer->nHeight, DX_BIT_2_9);
            if (emDXStatus != DX_OK) {
                printf("DxRaw16toRaw8 Failed, Error Code: %d\n", emDXStatus);
                return PIXFMT_CVT_FAIL;
            }
            // Convert to the RGB24 image
            emDXStatus = DxRaw8toRGB24(g_pRaw8Image, g_pRGBImageBuf, pFrameBuffer->nWidth, pFrameBuffer->nHeight,
                                       RAW2RGB_NEIGHBOUR, DX_PIXEL_COLOR_FILTER(g_i64ColorFilter), false);
            if (emDXStatus != DX_OK) {
                printf("DxRaw8toRGB24 Failed, Error Code: %d\n", emDXStatus);
                return PIXFMT_CVT_FAIL;
            }
            break;
        }
        default: {
            printf("Error : PixelFormat of this camera is not supported\n");
            return PIXFMT_CVT_FAIL;
        }
    }
    return PIXFMT_CVT_SUCCESS;
}

void PreForAcquisition() {
    g_pRGBImageBuf = new unsigned char[g_nPayloadSize * 3];
    g_pRaw8Image = new unsigned char[g_nPayloadSize];
}

void UnPreForAcquisition() {
    if (g_pRaw8Image != nullptr) {
        delete[] g_pRaw8Image;
        g_pRaw8Image = nullptr;
    }
    if (g_pRGBImageBuf != nullptr) {
        delete[] g_pRGBImageBuf;
        g_pRGBImageBuf = nullptr;
    }
}

void *ProcGetImage(void *pParam) {
    GX_STATUS emStatus = GX_STATUS_SUCCESS;

    //Thread running flag setup
    g_bAcquisitionFlag = true;
    PGX_FRAME_BUFFER pFrameBuffer = nullptr;

    time_t lInit;
    time_t lEnd;
    uint32_t ui32FrameCount = 0;

    while (g_bAcquisitionFlag) {
        if (!ui32FrameCount) {
            time(&lInit);
        }

        // Get a frame from Queue
        emStatus = GXDQBuf(g_hDevice, &pFrameBuffer, 1000);
        if (emStatus != GX_STATUS_SUCCESS) {
            if (emStatus == GX_STATUS_TIMEOUT) {
                continue;
            } else {
                GetErrorString(emStatus);
                break;
            }
        }

        if (pFrameBuffer->nStatus != GX_FRAME_STATUS_SUCCESS) {
            printf("<Abnormal Acquisition: Exception code: %d>\n", pFrameBuffer->nStatus);
        } else {
            ui32FrameCount++;
            time(&lEnd);
            // Print acquisition info each second.
            if (lEnd - lInit >= 1) {
                printf("<Successful acquisition: FrameCount: %u Width: %d Height: %d FrameID: %lu>\n",
                       ui32FrameCount, pFrameBuffer->nWidth, pFrameBuffer->nHeight, pFrameBuffer->nFrameID);
                ui32FrameCount = 0;
            }

            if (g_bSavePPMImage) {
                int nRet = PixelFormatConvert(pFrameBuffer);
                if (nRet == PIXFMT_CVT_SUCCESS) {
                    SavePPMFile(pFrameBuffer->nWidth, pFrameBuffer->nHeight);
                } else {
                    printf("PixelFormat Convert failed!\n");
                }
                g_bSavePPMImage = false;
            }
        }

        emStatus = GXQBuf(g_hDevice, pFrameBuffer);
        if (emStatus != GX_STATUS_SUCCESS) {
            GetErrorString(emStatus);
            break;
        }
    }
    printf("<Acquisition thread Exit!>\n");

    return nullptr;
}

// TODO 显示报错内容
void GetErrorString(GX_STATUS emErrorStatus) {

    char *error_info = nullptr;
    size_t size = 0;
    GX_STATUS emStatus = GX_STATUS_SUCCESS;

    emStatus = GXGetLastError(&emErrorStatus, nullptr, &size);
    if (emStatus != GX_STATUS_SUCCESS) {
        // TODO 未知错误
        return;
    }

    error_info = new char[size];
    if (error_info == nullptr) {
        // TODO 内存已满
        return;
    }

    emStatus = GXGetLastError(&emErrorStatus, error_info, &size);
    if (emStatus != GX_STATUS_SUCCESS) {
        // TODO 未知错误
    } else {
        printf("%s\n", error_info);
    }

    if (error_info != nullptr) {
        delete[] error_info;
        error_info = nullptr;
    }
}
